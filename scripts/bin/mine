#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Tim Henderson (tadh@case.edu)
#
# This file is part of jpdg a library to generate Program Dependence Graphs
# from JVM bytecode.
#
# Copyright (c) 2014, Tim Henderson, Case Western Reserve University
#   Cleveland, Ohio 44106
#   All Rights Reserved.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc.,
#   51 Franklin Street, Fifth Floor,
#   Boston, MA  02110-1301
#   USA
# or retrieve version 2.1 at their website:
#   http://www.gnu.org/licenses/lgpl-2.1.html


import os, sys, time, subprocess, tempfile, shutil
try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

import optutils
from optutils import output, log, error_codes, add_code

from jpdg import config
from jpdg.slicer import Slicer
from jpdg.dotty import dotty

__version__ = 'git master'

add_code('version')
add_code('config')
add_code('jpdg')
add_code('parsemis')

def version():
    '''Print version and exits'''
    log('version :', __version__)
    sys.exit(error_codes['version'])

def build_jpdg(conf):
    cwd = os.getcwd()
    os.chdir(conf.jpdg_root)
    try:
        subprocess.check_call([
            'buildr', 'jpdg:package', 'test=no'
        ])
    finally:
        os.chdir(cwd)

def build_parsemis(conf):
    cwd = os.getcwd()
    os.chdir(conf.jpdg_root)
    try:
        subprocess.check_call([
            'buildr', 'parsemis:package', 'test=no'
        ])
    finally:
        os.chdir(cwd)

def build_slicer(conf):
    subprocess.check_call([
        'go', 'install', 'cwru/selab/slice/slicebot',
    ])

def run_jpdg(conf, name, subject, output, no_build=False, jpdg_logs=False):
    if not no_build:
        build_jpdg(conf)
    cmd = list(subject.jpdg_cmd)
    cmd.append(output)
    print >>sys.stderr, '>', ' '.join(cmd)
    if not jpdg_logs:
        p = subprocess.Popen(cmd,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    else:
        p = subprocess.Popen(cmd)
    if p.wait() != 0:
        if not jpdg_logs:
            print >>sys.stderr, p.stdout.read()
            print >>sys.stderr, p.stderr.read()
        print >>sys.stderr, "Calling jpdg failed"
        print >>sys.stderr
        for arg in cmd[:-1]:
            print >>sys.stderr, arg, '\\'
        print >>sys.stderr, cmd[-1]
        sys.exit(error_codes['jpdg'])

def run_parsemis(conf, dotty_output, parsemis_output, no_build=False,
        parsemis_logs=False, pattern_min='50%'):
    if not no_build:
        build_parsemis(conf)
    cmd = list(conf.parsemis_cmd)
    cmd += [
        '--graphFile='+dotty_output,
        '--outputFile='+parsemis_output,
        '--closeGraph=true',
        '--algorithm=gspan',
        '--minimumFrequency='+pattern_min,
        '--minimumNodeCount=3',
        '--minimumEdgeCount=3',
        '--maximumNodeCount=10',
    ]
    print >>sys.stderr, '>', ' '.join(cmd)
    if not parsemis_logs:
        p = subprocess.Popen(cmd,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    else:
        p = subprocess.Popen(cmd)
    if p.wait() != 0:
        if not parsemis_logs:
            print >>sys.stderr, p.stdout.read()
            print >>sys.stderr, p.stderr.read()
        print >>sys.stderr, "Calling parsemis failed"
        print >>sys.stderr
        for arg in cmd[:-1]:
            print >>sys.stderr, arg, '\\'
        print >>sys.stderr, cmd[-1]
        sys.exit(error_codes['parsemis'])

def run_graphviz(dot_file):
    cmd = [
        'sed', '-i', '/transparent/d', dot_file
    ]
    print >>sys.stderr, '>', ' '.join(cmd)
    subprocess.check_call(cmd)
    cmd = [
        'dot', '-Tpng', '-O', dot_file
    ]
    print >>sys.stderr, '>', ' '.join(cmd)
    subprocess.check_call(cmd)

@optutils.main(
    'usage: mine [-c subjects.conf] <subject> <command>',
    '''
    Example:

        $ mine jgit validate

    Options
        -h, help                      print this message
        -v, version                   print the version
        -c, config=<config>           config for subjects

    Specs
        <subject>                     name of the subject to process
        <config>                      configuration file path

    Configuration File Format
        The config file should be written in json. By default `mine` looks at
        $(pwd)/subjects.conf, and $HOME/.jpdg-subjects.conf for files and
        cascades them (with the current working directory taking precedence).

        Schema
            {
                "subjects" : {
                    subject_name: {
                        "base_dir": <path>,
                        "classpath": <path>,
                        "lib_dirs": [ <path> ],
                        "class_dirs": [ <path> ],
                        "target": <path>,
                    }
                }
            }

        Specs
            <path>                    a file path. May contain shell vars
    ''',
    'hvc:',
    ['help', 'version', 'config=']
)
def main(argv, util, parser):
    """
    The main entry point to the program
    """

    @util.command(
        'print the runtime config for a subject',
        '''
        mine <subject> validate


        Options
            -h, help                      print this message
        ''',
        'h',
        ['help',],
    )
    def validate(argv, util, parser, conf, name, subject):

        opts, args = parser(argv)
        for opt, arg in opts:
            if opt in ('-h', '--help',):
                util.usage()

        print 'running with', name, subject


    @util.command(
        'runs jpdg on the subject',
        '''
        mine <subject> jpdg -o <path>

        Options
            -h, help                      print this message
            -o, output=<path>             (required) where to put the output
            --no-build-jpdg               don't build jpdg
            --jpdg-logs                   show the jpdg log output
        ''',
        'ho:',
        ['help', 'output=', 'no-build-jpdg', 'jpdg-logs'],
    )
    def jpdg(argv, util, parser, conf, name, subject):

        output = None
        no_build = False
        jpdg_logs = False
        opts, args = parser(argv)
        for opt, arg in opts:
            if opt in ('-h', '--help',):
                util.usage()
            elif opt in ('-o', '--output',):
                output = os.path.abspath(arg)
            elif opt in ('--no-build-jpdg',):
                no_build = True
            elif opt in ('--jpdg-logs',):
                jpdg_logs = True

        if output is None:
            print >>sys.stderr, "You must supply the output file"
            util.usage()

        run_jpdg(conf, name, subject, output, no_build, jpdg_logs)

    @util.command(
        'runs slice on the subject',
        '''
        mine <subject> patterns -o <directory>

        Options
            -h, help                      print this message
            -o, output=<path>             (required) where to put the output
            -m, minimum=<int>             minimum number of call sites to mine
            -p, pattern-min=<int>%        minimum support in pattern mining
            --no-build                    don't build sub-programs
            --jpdg-logs                   show the jpdg log output
        ''',
        'ho:m:p:',
        ['help', 'no-build', 'jpdg-logs', 'minimum=', 'pattern-min=']
    )
    def patterns(argv, util, parser, conf, name, subject):

        output = None
        no_build = False
        jpdg_logs = False
        minimum = 1
        pattern_min = '50%'
        opts, args = parser(argv)
        for opt, arg in opts:
            if opt in ('-h', '--help',):
                util.usage()
            elif opt in ('-o', '--output',):
                output = arg
            elif opt in ('-m', '--minimum',):
                minimum = util.parse_int(arg)
            elif opt in ('-p', '--pattern-min',):
                pattern_min = arg
            elif opt in ('--no-build',):
                no_build = True
            elif opt in ('--jpdg-logs',):
                jpdg_logs = True

        if output is None:
            print >>sys.stderr, "You must supply the output file"
            util.usage(error_codes['option'])

        if os.path.exists(output):
            if os.path.isdir(output):
                shutil.rmtree(output)
            else:
                print >>sys.stderr, "output must be a directory"
                util.usage(error_codes['option'])

        util.assert_dir_exists(output)

        if not no_build:
            build_jpdg(conf)
            build_parsemis(conf)
            build_slicer(conf)
        jpdg_output = os.path.join(output, 'graph.pdg')
        run_jpdg(conf, name, subject, jpdg_output, True, jpdg_logs)

        slicer = Slicer()
        try:
            slicer.load(jpdg_output)
            for i, c in enumerate(slicer.candidates('3:call')):
                if c['count'] < minimum:
                    continue
                slices = slicer.slice(c['label'], filtered_edges=['cfg'])
                memfile = StringIO(slices)
                dotty_output = os.path.join(output, 'slice.%d.dot' % i)
                with open(dotty_output, 'w') as f:
                    dotty(memfile, f, html=False)
                if os.stat(dotty_output).st_size == 0:
                    os.unlink(dotty_output)
                    continue
                parsemis_output = os.path.join(output, "patterns.%d.dot" % i)
                run_parsemis(
                    conf,
                    dotty_output,
                    parsemis_output,
                    no_build=True,
                    pattern_min=pattern_min,
                )
                if os.stat(parsemis_output).st_size == 0:
                    os.unlink(parsemis_output)
                else:
                    run_graphviz(parsemis_output)
        finally:
            slicer.close()

    opts, args = parser(argv)
    cpaths = list()
    for opt, arg in opts:
        if opt in ('-h', '--help',):
            util.usage()
        elif opt in ('-v', '--version',):
            version()
        elif opt in ('-c', '--config',):
            cpaths.append(arg)

    try:
        conf = config.Configuration(cpaths)
    except Exception, e:
        print >>sys.stderr, "Could not load the configuration"
        for err in e.args:
            print >>sys.stderr, err
        print >>sys.stderr
        util.usage(error_codes['config'])

    if len(args) == 0:
        print >>sys.stderr, "You must give a subject"
        print >>sys.stderr, "valid subjects are", conf.subjects.keys()
        for err in conf.errors:
            print >>sys.stderr, 'WARNING', err
        util.usage(error_codes['option'])

    subject_name = args[0]
    if subject_name not in conf.subjects:
        print >>sys.stderr, "Subject %s not in config files." % subject_name
        print >>sys.stderr, "valid subjects are", conf.subjects.keys()
        for err in conf.errors:
            print >>sys.stderr, 'WARNING', err
        util.usage(error_codes['option'])
    subject = conf.subjects[subject_name]

    util.run_command(args[1:], conf, subject_name, subject)

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))

